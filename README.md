# Парадигмы программирования у2020
##### Решения домашних заданий курса "Парадигмы программирования"
## 1. [Бинарный поиск](https://github.com/ptyvvs/itmo-paradigms/blob/main/java-solutions/search/BinarySearchMissing.java)
##### Условия
Реализуйте итеративный и рекурсивный варианты бинарного поиска в массиве.
На вход подается целое число x и массив целых чисел a, отсортированный по невозрастанию. Требуется найти минимальное значение индекса i, при котором a[i] <= x.
Для функций бинарного поиска и вспомогательных функций должны быть указаны, пред- и постусловия. Для реализаций методов должны быть приведены доказательства соблюдения контрактов в терминах троек Хоара.
##### Интерфейс программы
Первый аргумент командной строки — число x.<br/>
Последующие аргументы командной строки — элементы массива a.<br/>
Пример запуска: `java BinarySearch 3 5 4 3 2 1`. Ожидаемый результат: `2`.<br/>
##### Модификация
Если в массиве a отсутствует элемент, равный x, то требуется вывести индекс вставки в формате, определенном в `Arrays.binarySearch`.<br/>
Класс должен иметь имя `BinarySearchMissing`
## 2. [Очередь на массиве](https://github.com/ptyvvs/itmo-paradigms/tree/main/java-solutions/queue)
##### Условия
Определите модель и найдите инвариант структуры данных «очередь». Определите функции, которые необходимы для реализации очереди. Найдите их пред- и постусловия, при условии что очередь не содержит null.<br/>
Реализуйте классы, представляющие циклическую очередь с применением массива.<br/>
Класс `ArrayQueueModule` должен реализовывать один экземпляр очереди с использованием переменных класса.<br/>
Класс `ArrayQueueADT` должен реализовывать очередь в виде абстрактного типа данных (с явной передачей ссылки на экземпляр очереди).<br/>
Класс `ArrayQueue` должен реализовывать очередь в виде класса (с неявной передачей ссылки на экземпляр очереди).<br/>
Должны быть реализованы следующие функции (процедуры) / методы:

- `enqueue` – добавить элемент в очередь;
- `element` – первый элемент в очереди;
- `dequeue` – удалить и вернуть первый элемент в очереди;
- `size` – текущий размер очереди;
- `isEmpty` – является ли очередь пустой;
- `clear` – удалить все элементы из очереди.

Инвариант, пред- и постусловия записываются в исходном коде в виде комментариев.
Обратите внимание на инкапсуляцию данных и кода во всех трех реализациях.
Напишите тесты к реализованным классам.
##### Модификация
Реализовать метод `toArray`, возвращающий массив, содержащий элементы, лежащие в очереди в порядке от головы к хвосту.
Исходная очередь должна остаться неизменной
Дублирования кода быть не должно
## 3. [Очередь на связном списке](https://github.com/ptyvvs/itmo-paradigms/tree/main/java-solutions/queue)
##### Условия
Определите интерфейс очереди Queue и опишите его контракт.<br/>
Реализуйте класс `LinkedQueue` — очередь на связном списке.<br/>
Выделите общие части классов `LinkedQueue` и `ArrayQueue` в базовый класс AbstractQueue.<br/>
##### Модификация
Добавить в интерфейс очереди и реализовать метод `toArray`, возвращающий массив, содержащий элементы, лежащие в очереди в порядке от головы к хвосту.
## 4. [Функциональные выражения на JavaScript](https://github.com/ptyvvs/itmo-paradigms/blob/main/javascript-solutions/functionalExpression.js)
##### Условия
Разработайте функции `cnst`, `variable`, `add`, `subtract`, `multiply`, `divide`, `negate` для вычисления выражений с одной переменной.
Функции должны позволять производить вычисления вида:<br/>
`let expr = subtract(
    multiply(
        cnst(2),
        variable("x")
    ),
    cnst(3)
);`
`println(expr(5));`          
При вычислении такого выражения вместо каждой переменной подставляется значение, переданное в качестве параметра функции expr (на данном этапе имена переменных игнорируются). Таким образом, результатом вычисления приведенного примера должно стать число 7.<br/>
Тестовая программа должна вычислять выражение x2−2x+1, для x от 0 до 10.<br/>
При выполнение задания следует обратить внимание на:
- Применение функций высшего порядка.
- Выделение общего кода для операций.
##### Модификация
Дополнительно реализовать поддержку переменных `y`, `z`
## 5. [Объектные выражения на JavaScript](https://github.com/ptyvvs/itmo-paradigms/blob/main/javascript-solutions/objectExpression.js)
##### Условия
Разработайте классы `Const`, `Variable`, `Add`, `Subtract`, `Multiply`, `Divide`, `Negate` для представления выражений с одной переменной.<br/>
Пример описания выражения 2x-3:<br/>
`let expr = new Subtract(
    new Multiply(
        new Const(2),
        new Variable("x")
    ),
    new Const(3)
);`

`println(expr.evaluate(5));`
                    
При вычислении такого выражения вместо каждой переменной подставляется её значение, переданное в качестве аргумента метода evaluate. Таким образом, результатом вычисления приведенного примера должно стать число 7.<br/>
Метод `toString()` должен выдавать запись выражения в обратной польской записи. Например, `expr.toString()` должен выдавать `"2 x * 3 -"`
##### Модификация
Дополнительно реализовать поддержку функций:
- `ArcTan (atan)` – арктангенс, `1256 atan` примерно равно `1.57`;
- `ArcTan2 (atan2)` – арктангенс, `841 540 atan2` примерно равно `1`;
## 6. [Обработка ошибок на JavaScript](https://github.com/ptyvvs/itmo-paradigms/blob/main/javascript-solutions/objectExpression.js)
##### Условия
Добавьте в предыдущее домашнее задание функцию `parsePrefix(string)`, разбирающую выражения, задаваемые записью вида `(- (* 2 x) 3)`. Если разбираемое выражение некорректно, метод `parsePrefix` должен бросать человеко-читаемое сообщение об ошибке.<br/>
Добавьте в предыдущее домашнее задание метод `prefix()`, выдающий выражение в формате, ожидаемом функцией `parsePrefix`.
##### Модификация
Дополнительно реализовать поддержку унарных операций:
- `Sinh (sinh)` – гиперболический синус, `(sinh 3)` немного больше `10`;
- `Cosh (cosh)` – гиперболический косинус, `(cosh 3)` немного меньше `10`;
## 7. [ Линейная алгебра на Clojure](https://github.com/ptyvvs/itmo-paradigms/blob/main/clojure-solutions/linear.clj)
##### Условия
Разработайте функции для работы с объектами линейной алгебры, которые представляются следующим образом:<br/>
- скаляры – числа
- векторы – векторы чисел;
- матрицы – векторы векторов чисел.

Функции над векторами:

- `v+/v-/v*/vd` – покоординатное сложение/вычитание/умножение/деление;
- `scalar/vect` – скалярное/векторное произведение;
- `v*s` – умножение на скаляр.<br/>

Функции над матрицами:

- `m+/m-/m*/md` – поэлементное сложение/вычитание/умножение/деление;
- `m*s` – умножение на скаляр;
- `m*v` – умножение на вектор;
- `m*m` – матричное умножение;
- `transpose` – транспонирование;
##### Модификация
Назовем *кубоидом* трехмерную прямоугольную таблицу чисел.
Добавьте операции поэлементного сложения `(c+)`, вычитания `(c-)`, умножения `(c*)` и деления `(cd)` кубоидов. Например, `(с+ [[[1] [2]] [[3] [4]]] [[[5] [6]] [[7] [8]]])` должно быть равно `[[[6] [8]] [[10] [12]]]`.
## 8. [Функциональные выражения на Clojure](https://github.com/ptyvvs/itmo-paradigms/blob/main/clojure-solutions/expression.clj)
##### Условия
Разработайте функции `constant`, `variable`, `add`, `subtract`, `multiply` и `divide` для представления арифметических выражений.
Пример описания выражения 2x-3:
`(def expr
  (subtract
    (multiply
      (constant 2)
      (variable "x"))
    (constant 3)))`
                    
Выражение должно быть функцией, возвращающей значение выражения при подстановке переменных, заданных отображением. Например, `(expr {"x" 2})` должно быть равно `1`.<br/>
Разработайте разборщик выражений, читающий выражения в стандартной для Clojure форме. Например,
`(parseFunction "(- (* 2 x) 3)")`
должно быть эквивалентно `expr`.
##### Модификация
Дополнительно реализовать поддержку унарных операций:
- `sin` – синус, `(sin 4846147)` примерно равно `1`;
- `cos` – косинус, `(cos 5419351)` примерно равно `1`.
## 9. [Объектные выражения на Clojure](https://github.com/ptyvvs/itmo-paradigms/blob/main/clojure-solutions/expression.clj)
##### Условия
Разработайте конструкторы `Constant`, `Variable`, `Add`, `Subtract`, `Multiply` и `Divide` для представления выражений с одной переменной.
Пример описания выражения 2x-3:
`(def expr
  (Subtract
    (Multiply
      (Constant 2)
      (Variable "x"))
    (Constant 3)))`
                    
Функция `(evaluate expression vars)` должна производить вычисление выражения `expression` для значений переменных, заданных отображением `vars`. Например, `(evaluate expr {"x" 2})` должно быть равно `1`.<br/>
Функция `(toString expression)` должна выдавать запись выражения в стандартной для Clojure форме.<br/>
Функция `(parseObject "expression")` должна разбирать выражения, записанные в стандартной для Clojure форме. Например,
`(parseObject "(- (* 2 x) 3)")`
должно быть эквивалентно `expr`.<br/>
Функция `(diff expression "variable")` должена возвращать выражение, представляющее производную исходного выражения по заданой пермененной. Например, `(diff expression "x")` должен возвращать выражение, эквивалентное `(Constant 2)`, при этом выражения `(Subtract (Constant 2) (Constant 0))` и
`(Subtract
  (Add
    (Multiply (Constant 0) (Variable "x"))
    (Multiply (Constant 2) (Constant 1)))
  (Constant 0))`
                    
так же будут считаться правильным ответом.
##### Модификация
Дополнительно реализовать поддержку унарных операций:
- `Sin (sin)` – синус, `(sin 4846147)` примерно равно `1`;
- `Cos (cos)` – косинус, `(cos 5419351)` примерно равно `1`.
## 10. [Простые числа на Prolog](https://github.com/ptyvvs/itmo-paradigms/blob/main/prolog-solutions/primes.pl)
##### Условия
Разработайте правила:
- `prime(N)`, проверяющее, что N – простое число.
- `composite(N)`, проверяющее, что N – составное число.
- `prime_divisors(N, Divisors)`, проверяющее, что список `Divisors` содержит все простые делители числа N, упорядоченные по возрастанию. Если N делится на простое число P несколько раз, то `Divisors` должен содержать соответствующее число копий P.
##### Модификация
Добавьте правило `square_divisors(N, D)`, возвращающее делители N²: `square_divisors(6, [2, 2, 3, 3])`
## 11. [Деревья поиска на Prolog](https://github.com/ptyvvs/itmo-paradigms/blob/main/prolog-solutions/tree-map.pl)
Реализовано декартово дерево
##### Условия
Реализуйте ассоциативный массив `(map)` на основе деревьев поиска. Для решения можно реализовать любое дерево поиска логарифмической высоты.
Разработайте правила:
- `map_build(ListMap, TreeMap)`, строящее дерево из упорядоченного списка пар ключ-значение (O(n));
- `map_get(TreeMap, Key, Value)`, проверяющее, что массив содержит заданную пару ключ-значение (O(log n)).
##### Модификация
Добавьте правила:
- `map_containsKey(Map, Key)`, проверяющее наличие ключа в дереве;
- `map_containsValue(Map, Value)`, проверяющее наличие значения в дереве;
- `map_getLast(Map, (Key, Value))`, возвращающее максимальную пару;
- `map_removeLast(Map, Result)`, удаляющее максимальную пару.




